// Generated by CoffeeScript 1.4.0
(function() {
  var Block, DeadDialog, Dialog, Dirt, Entity, GameScreen, Gravel, Ladder, Level, LevelDialog, Ninja, Particle, Particles, Player, Rock, Screen, TitleScreen, Treasure, WinDialog, digParticles, gfx, keys, levels, sound, utils,
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  utils = {
    counter: function(max, speed) {
      if (speed == null) {
        speed = 100;
      }
      return Math.floor(this.now() / speed % max);
    },
    now: function() {
      return new Date().getTime();
    },
    snap: function(value, snapSize) {
      return Math.floor(value / snapSize) * snapSize;
    },
    rand: function(min, max) {
      var range;
      if (!(max != null)) {
        max = min;
        min = 0;
      }
      range = max - min;
      return Math.floor((Math.random() * range) + min);
    }
  };

  gfx = {
    tileW: 24,
    tileH: 24,
    init: function() {
      var canvas;
      canvas = $("#game")[0];
      this.ctx = canvas != null ? typeof canvas.getContext === "function" ? canvas.getContext("2d") : void 0 : void 0;
      if (!this.ctx) {
        return false;
      }
      this.w = canvas.width;
      this.h = canvas.height;
      return true;
    },
    clear: function() {
      return this.ctx.clearRect(0, 0, this.w, this.h);
    },
    load: function(onload) {
      this.sprites = new Image();
      this.sprites.src = "resources/sprites.png";
      this.sprites.onload = function() {
        return onload();
      };
      this.title = new Image();
      return this.title.src = "resources/title.png";
    },
    drawSprite: function(col, row, x, y, w, h, scale) {
      if (w == null) {
        w = 1;
      }
      if (h == null) {
        h = 1;
      }
      if (scale == null) {
        scale = 1;
      }
      w *= this.tileW;
      h *= this.tileH;
      return this.ctx.drawImage(this.sprites, col * w, row * h, w, h, x, y, w * scale, h * scale);
    }
  };

  keys = {
    up: false,
    down: false,
    left: false,
    right: false,
    space: false,
    reset: function() {
      return this.up = this.down = this.left = this.right = this.space = false;
    },
    trigger: function(keyCode, isDown) {
      switch (keyCode) {
        case 37:
          return this.left = isDown;
        case 39:
          return this.right = isDown;
        case 38:
          return this.up = isDown;
        case 40:
          return this.down = isDown;
        case 32:
          if (isDown) {
            console.log("FIRE AWAY!");
          }
          return this.space = isDown;
      }
    }
  };

  $(document).keydown(function(e) {
    return keys.trigger(e.keyCode, true);
  });

  $(document).keyup(function(e) {
    return keys.trigger(e.keyCode, false);
  });

  sound = {
    audio: {},
    list: {
      "dig": "dig.wav",
      "fall": "falling.wav",
      "particle": "particle.wav",
      "dead": "dead.wav"
    },
    init: function() {
      var name, url, _ref, _results;
      _ref = this.list;
      _results = [];
      for (name in _ref) {
        url = _ref[name];
        _results.push(this.audio[name] = new Audio("resources/" + url));
      }
      return _results;
    },
    play: function(name) {
      var _ref, _ref1;
      if ((_ref = this.audio[name]) != null) {
        _ref.currentTime = 0;
      }
      return (_ref1 = this.audio[name]) != null ? _ref1.play() : void 0;
    }
  };

  sound.init();

  Level = (function() {

    Level.prototype.w = 0;

    Level.prototype.h = 0;

    Level.prototype.treasures = 0;

    Level.prototype.ninjas = [];

    Level.prototype.particles = [];

    function Level(level, game) {
      this.game = game;
      this.load(level);
    }

    Level.prototype.load = function(level) {
      var asciiMap, col, row, x, y;
      this.ninjas = [];
      this.treasures = 0;
      asciiMap = (function() {
        var _i, _len, _ref, _results;
        _ref = level.data.split("\n");
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          row = _ref[_i];
          _results.push(row.split(""));
        }
        return _results;
      })();
      this.map = (function() {
        var _i, _len, _results;
        _results = [];
        for (y = _i = 0, _len = asciiMap.length; _i < _len; y = ++_i) {
          row = asciiMap[y];
          _results.push((function() {
            var _j, _len1, _results1;
            _results1 = [];
            for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
              col = row[x];
              switch (col) {
                case "@":
                  _results1.push(new Dirt());
                  break;
                case "O":
                  _results1.push(new Rock());
                  break;
                case "P":
                  this.addPlayer(x, y);
                  _results1.push(new Block());
                  break;
                case "X":
                  this.addNinja(x, y);
                  _results1.push(new Block());
                  break;
                case "*":
                  this.treasures++;
                  _results1.push(new Treasure());
                  break;
                case "#":
                  _results1.push(new Ladder());
                  break;
                case "-":
                  _results1.push(new Ladder(true));
                  break;
                default:
                  _results1.push(new Block());
              }
            }
            return _results1;
          }).call(this));
        }
        return _results;
      }).call(this);
      this.h = this.map.length;
      return this.w = this.map[0].length;
    };

    Level.prototype.addNinja = function(x, y) {
      var ninja, xPos, yPos;
      xPos = x * gfx.tileW;
      yPos = y * gfx.tileH;
      ninja = new Ninja(this, xPos, yPos, this.game.player);
      return this.ninjas.push(ninja);
    };

    Level.prototype.addPlayer = function(x, y) {
      return this.game.setPlayer(x * gfx.tileW, y * gfx.tileH, this);
    };

    Level.prototype.removeBlock = function(x, y, block) {
      this.map[y][x] = new Block();
      if (block.constructor === Treasure) {
        if (--this.treasures === 0) {
          return game.dialog = new WinDialog();
        }
      }
    };

    Level.prototype.getBlockIndex = function(x, y) {
      return [Math.floor(x / gfx.tileW), Math.floor(y / gfx.tileH)];
    };

    Level.prototype.getBlockEdge = function(position, forVertical) {
      var snapTo;
      if (forVertical == null) {
        forVertical = false;
      }
      snapTo = !forVertical ? gfx.tileW : gfx.tileH;
      return utils.snap(position, snapTo);
    };

    Level.prototype.getBlock = function(x, y) {
      var xBlock, yBlock, _ref, _ref1;
      _ref = this.getBlockIndex(x, y), xBlock = _ref[0], yBlock = _ref[1];
      return ((_ref1 = this.map[yBlock]) != null ? _ref1[xBlock] : void 0) || new Rock();
    };

    Level.prototype.getBlocks = function() {
      var coords, x, y, _i, _len, _ref, _results;
      coords = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = coords.length; _i < _len; _i++) {
        _ref = coords[_i], x = _ref[0], y = _ref[1];
        _results.push(this.getBlock(x, y));
      }
      return _results;
    };

    Level.prototype.update = function() {
      var block, ninjas, p, row, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2;
      _ref = this.map;
      for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
        row = _ref[y];
        for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
          block = row[x];
          block.update(x, y, this);
        }
      }
      _ref1 = this.ninjas;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        ninjas = _ref1[_k];
        ninjas.update();
      }
      _ref2 = this.ninjas;
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        ninjas = _ref2[_l];
        this.checkCollision(this.game.player, ninjas);
      }
      return this.particles = (function() {
        var _len4, _m, _ref3, _results;
        _ref3 = this.particles;
        _results = [];
        for (_m = 0, _len4 = _ref3.length; _m < _len4; _m++) {
          p = _ref3[_m];
          if (p.update()) {
            _results.push(p);
          }
        }
        return _results;
      }).call(this);
    };

    Level.prototype.checkCollision = function(p, b) {
      if (p.x + p.w >= b.x && p.x <= b.x + b.w && p.y + p.h >= b.y && p.y <= b.y + b.h) {
        sound.play("dead");
        return game.dialog = new DeadDialog();
      }
    };

    Level.prototype.render = function(gfx) {
      var block, ninjas, p, row, x, y, _i, _j, _k, _l, _len, _len1, _len2, _len3, _ref, _ref1, _ref2, _results;
      _ref = this.map;
      for (y = _i = 0, _len = _ref.length; _i < _len; y = ++_i) {
        row = _ref[y];
        for (x = _j = 0, _len1 = row.length; _j < _len1; x = ++_j) {
          block = row[x];
          block.render(gfx, x * gfx.tileW, y * gfx.tileH);
        }
      }
      _ref1 = this.ninjas;
      for (_k = 0, _len2 = _ref1.length; _k < _len2; _k++) {
        ninjas = _ref1[_k];
        ninjas.render(gfx);
      }
      _ref2 = this.particles;
      _results = [];
      for (_l = 0, _len3 = _ref2.length; _l < _len3; _l++) {
        p = _ref2[_l];
        _results.push(p.render(gfx));
      }
      return _results;
    };

    Level.prototype.digAt = function(dir, x, y) {
      var block, xb, yb, _ref;
      _ref = this.getBlockIndex(x, y), xb = _ref[0], yb = _ref[1];
      xb = xb + (dir === "RIGHT" ? 1 : -1);
      if (yb + 1 > this.h || xb < 0 || xb > this.w - 1) {
        return;
      }
      block = this.map[yb + 1][xb];
      if (block.digIt != null) {
        block.digIt();
      }
      if (block.constructor === Block) {
        this.map[yb + 1][xb] = new Gravel();
      }
      this.addParticles(xb * gfx.tileW, (yb + 1) * gfx.tileH);
      return sound.play("dig");
    };

    Level.prototype.addParticles = function(x, y) {
      return this.particles.push(new Particles(x, y));
    };

    return Level;

  })();

  levels = [
    {
      name: "DIG and BUILD",
      data: ".P................X.....\n@-@@.........@@@@@@@-@..\n.#..@@@.............#...\n.#.....@@.@@.....X..#...\n@OO#.........#@@...O#..^\n...#.........#......#.^O\n...#..@@-@@@@#..-@@@@@OO\n...#....#....#..#.......\n...#....#....#..#.......\n...#....#....#..#.......\n@-@@OOOOO.#.@@@@@#@@-@@@\n.#.X......#......#..#...\n.#...*....#......#..#...\n####..@@#@@..-@@@@@@@..*\n####....#....#.........#\n####....#....#.........#\nOOOOOOOOOOOOOOOOOOOOOOOO"
    }
  ];

  Entity = (function() {

    Entity.prototype.x = 0;

    Entity.prototype.y = 0;

    Entity.prototype.w = 18;

    Entity.prototype.h = 24;

    Entity.prototype.speed = 4;

    Entity.prototype.dir = "LEFT";

    function Entity(level, x, y) {
      this.level = level;
      this.x = x;
      this.y = y;
      this.falling = true;
      this.wasFalling = true;
      this.onLadder = false;
      this.wasOnLadder = false;
      this.onTopOfLadder = false;
    }

    Entity.prototype.update = function() {};

    Entity.prototype.render = function(gfx) {
      return gfx.ctx.fillText("?", this.x, this.y);
    };

    Entity.prototype.move = function(x, y) {
      var bl, br, tl, tr, xo, xv, yo, yv, _ref, _ref1;
      if (this.falling) {
        y += this.speed * 2;
      }
      this.wasFalling = this.falling;
      xo = x;
      yo = y;
      xv = this.x + xo;
      yv = this.y + yo;
      _ref = this.level.getBlocks([this.x, yv], [this.x, yv + (this.h - 1)], [this.x + (this.w - 1), yv], [this.x + (this.w - 1), yv + (this.h - 1)]), tl = _ref[0], bl = _ref[1], tr = _ref[2], br = _ref[3];
      if (y < 0 && (tl.solid || tr.solid)) {
        yo = this.level.getBlockEdge(this.y, "VERT") - this.y;
      }
      if (y > 0 && (bl.solid || br.solid)) {
        yo = this.level.getBlockEdge(yv + (this.h - 1), "VERT") - this.y - this.h;
        this.falling = false;
      }
      _ref1 = this.level.getBlocks([xv, this.y], [xv, this.y + (this.h - 1)], [xv + (this.w - 1), this.y], [xv + (this.w - 1), this.y + (this.h - 1)]), tl = _ref1[0], bl = _ref1[1], tr = _ref1[2], br = _ref1[3];
      if (x < 0 && (tl.solid || bl.solid)) {
        xo = this.level.getBlockEdge(this.x) - this.x;
      }
      if (x > 0 && (tr.solid || br.solid)) {
        xo = this.level.getBlockEdge(xv + (this.w - 1)) - this.x - this.w;
      }
      this.x += xo;
      this.y += yo;
      return this.checkNewPos(x, y);
    };

    Entity.prototype.checkNewPos = function(origX, origY) {
      var bl, block, br, nearBlocks, snapAmount, tl, touchingALadder, tr, _i, _len, _ref;
      this.wasOnLadder = this.onLadder;
      nearBlocks = (_ref = this.level.getBlocks([this.x, this.y], [this.x, this.y + this.h], [this.x + (this.w - 1), this.y], [this.x + (this.w - 1), this.y + this.h]), tl = _ref[0], bl = _ref[1], tr = _ref[2], br = _ref[3], _ref);
      for (_i = 0, _len = nearBlocks.length; _i < _len; _i++) {
        block = nearBlocks[_i];
        if (block.touchable) {
          block.touch(this);
        }
      }
      this.onLadder = false;
      touchingALadder = nearBlocks.some(function(block) {
        return block.climbable;
      });
      if (touchingALadder) {
        this.onLadder = true;
        this.falling = false;
        if (origY !== 0) {
          snapAmount = utils.snap(this.x, gfx.tileW);
          if (!(bl.climbable || tl.climbable)) {
            this.x = snapAmount + gfx.tileW;
          }
          if (!(br.climbable || tr.climbable)) {
            this.x = snapAmount;
          }
        }
      }
      this.onTopOfLadder = this.onLadder && !(tl.climbable || tr.climbable) && (this.y + this.h) % gfx.tileH === 0;
      if (!this.onLadder && !this.falling) {
        if (!(bl.solid || br.solid || bl.climbable || br.climbable)) {
          return this.falling = true;
        }
      }
    };

    return Entity;

  })();

  Player = (function(_super) {

    __extends(Player, _super);

    function Player() {
      Player.__super__.constructor.apply(this, arguments);
      this.dir = "RIGHT";
    }

    Player.prototype.update = function() {
      var xo, yo;
      xo = yo = 0;
      if (!this.falling) {
        if (keys.left) {
          xo -= this.speed;
          this.dir = "LEFT";
        }
        if (keys.right) {
          xo += this.speed;
          this.dir = "RIGHT";
        }
      }
      if (keys.down && this.onLadder) {
        yo += this.speed;
      }
      if (keys.up && this.onLadder && !this.onTopOfLadder) {
        yo -= this.speed;
      }
      if (keys.space) {
        this.dig();
      }
      return this.move(xo, yo);
    };

    Player.prototype.render = function(gfx) {
      var fx, fy, isLeft;
      fy = fx = 0;
      isLeft = this.dir === "LEFT";
      if (this.falling) {
        if (isLeft) {
          fx = 1;
        }
        fy = 2;
      } else {
        if (isLeft) {
          fx = 2;
        }
        if (keys.left || keys.right) {
          fx += utils.counter(2);
        }
      }
      return gfx.drawSprite(fx, fy, this.x, this.y);
    };

    Player.prototype.dig = function() {
      if (utils.now() - this.lastDig < (6 * 1000)) {
        return;
      }
      this.level.digAt(this.dir, this.x, this.y);
      return this.lastDig = utils.now();
    };

    return Player;

  })(Entity);

  Ninja = (function(_super) {

    __extends(Ninja, _super);

    Ninja.prototype.state = "CRUISING";

    Ninja.prototype.subState = "IDLE";

    function Ninja(level, x, y, player) {
      this.player = player;
      Ninja.__super__.constructor.call(this, level, x, y);
    }

    Ninja.prototype.speed = 3;

    Ninja.prototype.time = 0;

    Ninja.prototype.render = function(gfx) {
      var fx;
      fx = this.dir === "LEFT" ? 2 : 0;
      fx += utils.counter(2);
      return gfx.drawSprite(fx, 1, this.x, this.y);
    };

    Ninja.prototype.cruise = function(px, py) {
      var newMove, x, y;
      x = y = 0;
      switch (this.subState) {
        case "RIGHT":
          x += this.speed;
          this.dir = "RIGHT";
          break;
        case "LEFT":
          x -= this.speed;
          this.dir = "LEFT";
      }
      if (--this.time < 0) {
        newMove = utils.rand(5);
        this.time = utils.rand(20, 40);
        this.subState = (function() {
          switch (newMove) {
            case 0:
            case 1:
              return "LEFT";
            case 2:
            case 3:
              return "RIGHT";
            default:
              return "IDLE";
          }
        })();
      }
      if (this.onLadder && !this.wasOnLadder) {
        if (Math.random() < 0.5) {
          this.state = "HUNTING";
        }
      }
      if (py === this.y) {
        this.state = "HUNTING";
      }
      return [x, y];
    };

    Ninja.prototype.hunt = function(px, py) {
      var x, y;
      x = y = 0;
      if (py === this.y || this.onTopOfLadder) {
        if (px > this.x) {
          x += this.speed;
          this.dir = "RIGHT";
        } else {
          x -= this.speed;
          this.dir = "LEFT";
        }
      } else if (this.onLadder) {
        if (!this.onTopOfLadder && py < this.y) {
          y -= this.speed;
        }
        if (py > this.y) {
          y += this.speed;
        }
      } else {
        this.state = "CRUISING";
        this.subState = "LEFT";
      }
      return [x, y];
    };

    Ninja.prototype.update = function() {
      var px, py, xo, yo, _ref;
      _ref = (function() {
        var _ref;
        if (this.falling) {
          return [0, 0];
        } else {
          _ref = this.player, px = _ref.x, py = _ref.y;
          switch (this.state) {
            case "CRUISING":
              return this.cruise(px, py);
            case "HUNTING":
              return this.hunt(px, py);
          }
        }
      }).call(this), xo = _ref[0], yo = _ref[1];
      return this.move(xo, yo);
    };

    return Ninja;

  })(Entity);

  Block = (function() {

    Block.prototype.touchable = false;

    Block.prototype.solid = false;

    Block.prototype.climbable = false;

    function Block() {}

    Block.prototype.update = function() {};

    Block.prototype.render = function(gfx, x, y) {};

    return Block;

  })();

  Dirt = (function(_super) {

    __extends(Dirt, _super);

    function Dirt() {
      return Dirt.__super__.constructor.apply(this, arguments);
    }

    Dirt.prototype.solid = true;

    Dirt.prototype.render = function(gfx, x, y) {
      var oldAlpha;
      oldAlpha = gfx.ctx.globalAlpha;
      gfx.ctx.globalAlpha = 1 - this.digTime / 80;
      gfx.drawSprite(4, 1, x, y);
      return gfx.ctx.globalAlpha = oldAlpha;
    };

    Dirt.prototype.digIt = function() {
      this.digTime = 80;
      return this.solid = false;
    };

    Dirt.prototype.update = function() {
      if (--this.digTime === 50) {
        return this.solid = true;
      }
    };

    return Dirt;

  })(Block);

  Rock = (function(_super) {

    __extends(Rock, _super);

    function Rock() {
      return Rock.__super__.constructor.apply(this, arguments);
    }

    Rock.prototype.solid = true;

    Rock.prototype.render = function(gfx, x, y) {
      return gfx.drawSprite(4, 0, x, y);
    };

    return Rock;

  })(Block);

  Treasure = (function(_super) {

    __extends(Treasure, _super);

    Treasure.prototype.touchable = true;

    Treasure.prototype.collected = false;

    function Treasure() {
      this.yOff = Math.random() * Math.PI;
    }

    Treasure.prototype.touch = function(entity) {
      if (entity.constructor === Player) {
        return this.collected = true;
      }
    };

    Treasure.prototype.update = function(x, y, level) {
      this.yOff += Math.PI / 24;
      if (this.collected) {
        level.removeBlock(x, y, this);
        return sound.play("particle");
      }
    };

    Treasure.prototype.render = function(gfx, x, y) {
      var ySine;
      ySine = Math.floor(Math.sin(this.yOff) * 4);
      return gfx.drawSprite(5, 1, x, y + ySine);
    };

    return Treasure;

  })(Block);

  Ladder = (function(_super) {

    __extends(Ladder, _super);

    Ladder.prototype.climbable = true;

    function Ladder(top) {
      this.top = top;
      this.frame = top ? 6 : 5;
    }

    Ladder.prototype.render = function(gfx, x, y) {
      return gfx.drawSprite(this.frame, 0, x, y);
    };

    return Ladder;

  })(Block);

  Gravel = (function(_super) {

    __extends(Gravel, _super);

    function Gravel() {
      return Gravel.__super__.constructor.apply(this, arguments);
    }

    Gravel.prototype.solid = true;

    Gravel.prototype.digTime = 100;

    Gravel.prototype.update = function(x, y, level) {
      if (--this.digTime < 0) {
        return level.removeBlock(x, y, this);
      }
    };

    Gravel.prototype.render = function(gfx, x, y) {
      var oldAlpha;
      oldAlpha = gfx.ctx.globalAlpha;
      gfx.ctx.globalAlpha = this.digTime / 50;
      gfx.drawSprite(4, 2, x, y);
      return gfx.ctx.globalAlpha = oldAlpha;
    };

    return Gravel;

  })(Block);

  Screen = (function() {

    function Screen() {}

    Screen.prototype.update = function() {};

    Screen.prototype.render = function(gfx) {};

    return Screen;

  })();

  GameScreen = (function(_super) {

    __extends(GameScreen, _super);

    GameScreen.prototype.levelNumber = 0;

    function GameScreen() {
      this.player = new Player();
      this.startLevel();
    }

    GameScreen.prototype.setPlayer = function(x, y, level) {
      this.player.level = level;
      this.player.x = x;
      return this.player.y = y;
    };

    GameScreen.prototype.update = function() {
      this.level.update();
      return this.player.update();
    };

    GameScreen.prototype.startLevel = function() {
      this.level = new Level(levels[this.levelNumber], this);
      return game.dialog = new LevelDialog(levels[this.levelNumber].name);
    };

    GameScreen.prototype.levelComplete = function() {
      if (++this.levelNumber >= levels.length) {
        return game.win();
      } else {
        return this.startLevel();
      }
    };

    GameScreen.prototype.render = function(gfx) {
      var backX, backY, leftEdge, offx;
      gfx.ctx.save();
      gfx.ctx.scale(1.3, 1.3);
      leftEdge = 210;
      offx = this.player.x > leftEdge ? -this.player.x + leftEdge : 0;
      gfx.ctx.translate(offx, -this.player.y + 130);
      this.level.render(gfx);
      this.player.render(gfx);
      gfx.ctx.restore();
      backX = 1 - (this.player.x / gfx.w) * 100;
      backY = 1 - (this.player.y / gfx.h) * 100;
      return gfx.ctx.canvas.style.backgroundPosition = "" + backX + "px " + backY + "px";
    };

    return GameScreen;

  })(Screen);

  TitleScreen = (function(_super) {

    __extends(TitleScreen, _super);

    function TitleScreen() {
      return TitleScreen.__super__.constructor.apply(this, arguments);
    }

    TitleScreen.prototype.min = 20;

    TitleScreen.prototype.update = function() {
      if (this.min-- > 0) {
        return;
      }
      if (keys.space) {
        return game.screen = new GameScreen();
      }
    };

    TitleScreen.prototype.render = function(gfx) {
      var c;
      c = gfx.ctx;
      gfx.clear();
      c.drawImage(gfx.title, 180, 10);
      c.fillStyle = "#e0e0e0";
      c.font = "14pt monospace";
      gfx.drawSprite(5, 1, 480, 180);
      c.fillText("Collect all \"Pig’s Boffin\" particles.", 50, 210);
      return c.fillText("Press space to start...", 50, 240);
    };

    return TitleScreen;

  })(Screen);

  Dialog = (function() {

    function Dialog() {}

    Dialog.prototype.update = function() {};

    Dialog.prototype.render = function(gfx) {};

    return Dialog;

  })();

  LevelDialog = (function(_super) {

    __extends(LevelDialog, _super);

    LevelDialog.prototype.time = 50;

    function LevelDialog(level) {
      this.level = level;
    }

    LevelDialog.prototype.update = function() {
      if (--this.time === 0) {
        return game.dialog = null;
      }
    };

    LevelDialog.prototype.render = function(gfx) {
      var c;
      c = gfx.ctx;
      c.save();
      c.translate(100, 150);
      c.fillStyle = "hsla(205, 40%, 50%, 0.8)";
      c.fillRect(0, 0, 350, 200);
      c.fillStyle = "#e0e0e0";
      c.fillText("" + this.level, 50, 100);
      return c.restore();
    };

    return LevelDialog;

  })(Dialog);

  DeadDialog = (function(_super) {

    __extends(DeadDialog, _super);

    function DeadDialog() {
      return DeadDialog.__super__.constructor.apply(this, arguments);
    }

    DeadDialog.prototype.time = 100;

    DeadDialog.prototype.update = function() {
      if (--this.time === 0) {
        return game.reset();
      }
    };

    DeadDialog.prototype.render = function(gfx) {
      var c;
      c = gfx.ctx;
      c.save();
      c.translate(100, 150);
      c.fillStyle = "hsla(5, 40%, 50%, 0.8)";
      c.fillRect(0, 0, 350, 200);
      c.fillStyle = "#e0e0e0";
      c.fillText("Ninjas have killed you!", 50, 100);
      return c.restore();
    };

    return DeadDialog;

  })(Dialog);

  WinDialog = (function(_super) {

    __extends(WinDialog, _super);

    function WinDialog() {
      return WinDialog.__super__.constructor.apply(this, arguments);
    }

    WinDialog.prototype.time = 100;

    WinDialog.prototype.update = function() {
      if (--this.time === 0) {
        return game.reset();
      }
    };

    WinDialog.prototype.render = function(gfx) {
      var c;
      c = gfx.ctx;
      c.save();
      c.translate(100, 150);
      c.fillStyle = "hsla(105, 40%, 50%, 0.8)";
      c.fillRect(0, 0, 350, 200);
      c.fillStyle = "#e0e0e0";
      c.fillText("You WIN!!", 50, 100);
      return c.restore();
    };

    return WinDialog;

  })(Dialog);

  digParticles = {
    life: 20,
    num: 6,
    size: [6, 4],
    xStart: [-2, 8],
    yStart: [-5, 0],
    xVelocity: [-1, 0],
    yVelocity: [-4, -1],
    acc: [0, 0.3],
    col: {
      h: 20,
      s: 60,
      l: 40
    }
  };

  Particle = (function() {

    function Particle(x, y, opt) {
      this.opt = opt;
      this.a = 0.5;
      this.x = x + utils.rand(this.opt.xStart[0], this.opt.xStart[1]);
      this.y = y + utils.rand(this.opt.yStart[0], this.opt.yStart[1]);
      this.xVelocity = utils.rand(this.opt.xVelocity[0], this.opt.xVelocity[1]);
      this.yVelocity = utils.rand(this.opt.yVelocity[0], this.opt.yVelocity[1]);
    }

    Particle.prototype.update = function() {
      this.a -= 0.01;
      this.x += this.xVelocity;
      this.y += this.yVelocity;
      this.xVelocity += this.opt.acc[0];
      return this.yVelocity += this.opt.acc[1];
    };

    Particle.prototype.render = function(gfx) {
      gfx.ctx.fillStyle = "hsla(" + this.opt.col.h + ", " + this.opt.col.s + "%, " + this.opt.col.l + "%, " + this.a + ")";
      return gfx.ctx.fillRect(Math.floor(this.x), Math.floor(this.y), this.opt.size[0], this.opt.size[1]);
    };

    return Particle;

  })();

  Particles = (function() {

    function Particles(x, y, opt) {
      this.opt = opt != null ? opt : digParticles;
      this.life = this.opt.life;
      this.ps = (function() {
        var _i, _ref, _results;
        _results = [];
        for (_i = 0, _ref = this.opt.num; 0 <= _ref ? _i <= _ref : _i >= _ref; 0 <= _ref ? _i++ : _i--) {
          _results.push(new Particle(x, y, this.opt));
        }
        return _results;
      }).call(this);
    }

    Particles.prototype.update = function() {
      var p, _i, _len, _ref;
      _ref = this.ps;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        p.update();
      }
      return this.life-- > 0;
    };

    Particles.prototype.render = function(gfx) {
      var p, _i, _len, _ref, _results;
      _ref = this.ps;
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        p = _ref[_i];
        _results.push(p.render(gfx));
      }
      return _results;
    };

    return Particles;

  })();

  this.game = {
    dialog: null,
    screen: null,
    init: function() {
      if (!gfx.init()) {
        alert("Sorry, no canvas");
        return;
      }
      return gfx.load(function() {
        return game.reset();
      });
    },
    stop: function() {
      return this.running = false;
    },
    start: function() {
      return this.running = true;
    },
    reset: function() {
      this.dialog = null;
      this.screen = new TitleScreen();
      keys.reset();
      if (!this.running) {
        this.start();
        return this.tick();
      }
    },
    tick: function() {
      var _this = this;
      if (!this.running) {
        return;
      }
      this.update();
      this.render();
      return setTimeout((function() {
        return _this.tick();
      }), 33);
    },
    update: function() {
      if (this.dialog != null) {
        return this.dialog.update();
      } else {
        return this.screen.update();
      }
    },
    render: function() {
      gfx.clear();
      this.screen.render(gfx);
      if (this.dialog) {
        return this.dialog.render(gfx);
      }
    }
  };

}).call(this);
